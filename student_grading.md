# **üöÄ Python Course: CEFR-Style Competency Grid**

# This rubric evaluates your project as a professional deliverable. You are graded on your ability to move from a "Novice" (A-Level) to an "Architect" (C-Level) across three pillars of software production.

## **üü¢ Axis 1: Presentation Skills (30%)**

# _Focus: Communication, Value Proposition, and Product Readiness._

| **Level** | **Descriptor: "The Narrative & The Product"** | 
| :--- | :--- | 
| **C1/C2 (Architect)** | **I can lead a professional pitch.** My slides are visually clean and narrative-driven. I can conduct a flawless live demo that includes error handling. The product is an MVP that solves a real problem with an intuitive user interface. | 
| **B1/B2 (Developer)** | **I can explain my product clearly.** My slides are organized and cover all core features. My demo works for the "happy path," though it may falter on complex edge cases. The product meets all requirements and provides clear value to the user. | 
| **A1/A2 (Junior)** | **I can describe what I built.** My slides are text-heavy or disorganized. My demo is clunky or relies on screenshots because the live code is fragile. The product meets basic requirements but lacks a cohesive "user-first" feel. | 


## **üîµ Axis 2: The Technical Knowledge (40%)**

# _Focus: Logic Ownership, Live Implementation, and Algorithmic Thinking._

| **Level** | **Descriptor: "The Engine & The Logic"** | 
| :--- | :--- | 
| **C1/C2 (Architect)** | **I have total mastery over my codebase.** I can justify every library and architectural choice I made. I can implement a "Live Tweak" (minor feature change) instantly and correctly during the defense without external help. | 
| **B1/B2 (Developer)** | **I understand my technical implementation.** I can explain the logic behind my functions and loops. I can implement a "Live Tweak" with minor guidance on syntax, showing I know exactly where the logic resides. | 
| **A1/A2 (Junior)** | **I can follow the code flow.** I can explain what the code does, but I struggle to explain *why* specific choices were made. I struggle with "Live Tweaks," requiring significant help to identify the relevant code blocks to modify. | 


## **üü° Axis 3: Engineering Implementation (30%)**

# _Focus: Git Workflow, Documentation, and Code Quality._


| **Level** | **Descriptor: "The Repository & The Craft"** | 
| :--- | :--- | 
| **C1/C2 (Architect)** | **My code is production-ready.** My Git history shows a professional, incremental workflow (clear feature branches/commits). My code is PEP 8 compliant and modular. My README allows a stranger to deploy the app in under 60 seconds. | 
| **B1/B2 (Developer)** | **My code is clean and maintainable.** I used Git regularly during development. My code is organized into functions and uses meaningful names. My README includes setup steps and a clear project overview. | 
| **A1/A2 (Junior)** | **My code is functional but messy.** My Git history is an "LLM Dump" (one or two giant commits at the end). My code is monolithic (one big file) with inconsistent formatting. My README is vague or missing key setup details. | 



## **‚ö†Ô∏è Non-Negotiable "Auto-Fail" Conditions**

# Regardless of your level above, the project is considered **Incomplete (F)** if:1) **The Smoke Test Fails:** The code crashes immediately upon valid user input.

2) **The "Black Box" Effect:** The student cannot explain the logic of a core function in the project.

3) **The Ownership Gap:** The student cannot identify the location of requested changes in their own files.
